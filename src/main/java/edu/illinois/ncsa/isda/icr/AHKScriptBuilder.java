
/*
 * Builds an AHK script for converting an inputFile to an outputFile using a specific SW. 
 * The process is based on going over the "path" files (generated by the AHK ScriptConversionRecorder or manually)
 * The final script always runs the SW to be used, opens the inputFile and generates the outputFile, but may perform 
 * additional actions depending on the "path" files.
 * */

/*
 * changes:
 *			(1) added header lines, including JSON 
 *			(2) removed differentiation between actions that occur obligatory and those which don't
 *      	(3) write func to replace the input file string and the output file string (and paths and extensions if necessary)
 * 
 * TODO list:			
 *      (4) debug wait options
 * 			(5) write a rec func that takes a file and copies its contents to a new one in a way that 
 * 			every time there is if(curr_param="a"){}if(curr_param="b"){}if(curr_param="c"){}
 * 			it transforms to while((curr_param="a")or (curr_param="b")or (curr_param="c")){if(curr_param="a"){}if(curr_param="b"){}if(curr_param="c"){}}
 * 			this should be done only if there are no commands (other than comments) between the if's - maybe using files...
 * 			this because order of params has to be irrelevant (param names have to be unique) 
 * 			(6) skip a param that is not used... this is HARD
 *			(7) "ifwin" - deal with pop ups that do not always appear, but if they do, they have a fixed "time" to show up.
 *			for example, after a save operation a pop up may appear asking whether to override a file or not. 
 *			(8) advanceLine and nextWord should support/be able to parse also words with \" inside - basically check if after the \" we have
 *			a space or if it is the end of the line, if so, great! if not, we found a \" that is actually inside our word and we should look for the next \". 
 *			repeat the process.
 *
 * general comments:         
 *          (*) keeping in mind the goal of complete control of SW:
 *          		(a) every option should be optional since the user will have complete liberty to decide which 
 *          		actions to be taken and when - maybe the only action that will be always present is "run". 
 *          		this can be accomplished by recording one script per action. although it does not seem a good solution, there might not be 
 *          		another better solution because of the nested parameters which order could generate different results 
 *          		(b) in this case (total control), each possible action is transformed in a "parameter" and should probably (if no
 *          		better solution is found) be recorded separately. for example, a user will open a file using a "openFile=fileName"
 * 			(*) the option of saving text to file was introduced mainly to contribute towards the goal of total SW control.
 * 				right now, the name of the file to be written to is defined by the 'scripter'. A better approach however may be to 
 * 				have a predefined name to be used. If not, we should consider the option of having the user decide which name to use when
 * 				saving a file is an online decision.   
 * 
 * */


package edu.illinois.ncsa.isda.icr;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Vector;
import kgm.utility.Utility;
//import com.google.gson.Gson;


public class AHKScriptBuilder{
	static private int debug=1;
	
	/**
	 * AHKScriptBuilder can be called from cmd line by giving 2 arguments: output AHK script directory path and input files directory path 
	 **/
	public static void main(String[] args){
		String scriptFolderPath="C:\\Documents and Settings\\liana\\Desktop\\scripts_report\\";
		String roadmapFilesDirectory="C:\\temp\\";//"C:\\Documents and Settings\\liana\\Desktop\\testNew\\";
		String[] swFolders;
		File formatRoadmapFolder, mainRoadmapFolder, scriptFolder;
		
		if (args.length>0){
			if (args.length!=2){
				System.out.println("Usage: first argument is the resulting script folder (with complete path), second argument is the directory of roadmap files to be used");
				System.exit(1);
			}
			scriptFolderPath=args[0];
			roadmapFilesDirectory=args[1];
		}
		if(!roadmapFilesDirectory.endsWith("\\")){
			roadmapFilesDirectory+="\\";
		}
		scriptFolder=new File(scriptFolderPath);
		if(!scriptFolder.exists())
			scriptFolder.mkdir();

		if(!scriptFolderPath.endsWith("\\")){
			scriptFolderPath+="\\";
		}
		
		mainRoadmapFolder= new File(roadmapFilesDirectory);
		swFolders = mainRoadmapFolder.list();//list of softwares
		for(String f:swFolders){
			formatRoadmapFolder = new File(roadmapFilesDirectory+f);
			if (formatRoadmapFolder.isDirectory()){
				softwareWriteAllScripts(roadmapFilesDirectory+f, scriptFolderPath);
			}
		}
		if(debug==1)
			System.out.println("FINISHED");
	}
	
	
	public static void softwareWriteAllScripts(String swRoadMapDirectory, String scriptDirectory){
		String[] folders;
		String scriptPath;
		File script, formatRoadmapFolder, swRoadmapFolder;
	
		if(!scriptDirectory.endsWith("\\"))
			scriptDirectory+="\\";
		
		if(!swRoadMapDirectory.endsWith("\\"))
			swRoadMapDirectory+="\\";
		
		swRoadmapFolder = new File(swRoadMapDirectory);
		folders = swRoadmapFolder.list();//list of formats
		for(String format:folders){
			formatRoadmapFolder = new File(swRoadMapDirectory+format);
			if (formatRoadmapFolder.isDirectory()){
				scriptPath = scriptDirectory+swRoadmapFolder.getName()+"_convert_"+formatRoadmapFolder.getName()+".ahk";
				script = new File(scriptPath);
				if (script.exists())
					script.delete();
				writeScript(scriptPath, swRoadMapDirectory+format);
			}
		}
	}

	
	public static String findFilePath(File f,String command){
		String match="";
		String str;
		BufferedReader ins;
		try{
			ins = new BufferedReader(new FileReader(f));
			while((str=ins.readLine())!=null){
				if (nextWord(str).equalsIgnoreCase(command)){
					str = advanceLine(str);
					match=removeDoubleQuotes(nextWord(str));
					break;
				}
			}
			ins.close();
		}catch(Exception e){
			e.printStackTrace();
		}
		return match;
	}
	
	public static void replaceStringInScript(File f, String old_str, String new_str){
		String str;
		File new_f=new File("temp.txt");
		if(new_f.exists())
			new_f.delete();
		try{
		BufferedReader br = new BufferedReader(new FileReader(f));
		FileWriter fw = new FileWriter("temp.txt", true);
		
		int index;
		while((str=br.readLine())!=null){
			while((index=str.indexOf(old_str))!=-1){
				str = str.substring(0, index)+new_str+str.substring(index+old_str.length());
			}
			fw.write(str+"\r\n");
		}
		
		br.close();
		fw.close();
		f.delete();
		new_f.renameTo(f);
//		System.out.println(new_f.renameTo(f));
//		new_f.delete();
		}catch(Exception e){
			System.out.println(old_str);
			System.out.println(new_str);
			e.printStackTrace();
		}
		
		
	}
	
	
	
	public static void replaceScriptFileInfo(File[] files){
		String input_path_in_script="";
		String input_file_in_script="";
		String input_filename_in_script="";
		String output_path_in_script="";
		String output_file_in_script="";
		String output_filename_in_script="";
		
		for (int i=0; i<files.length; i++){
			if (files[i].isFile()){
				if (input_path_in_script.equalsIgnoreCase(""))input_path_in_script=findFilePath(files[i],"inputfile");
				if (output_path_in_script.equalsIgnoreCase("")) output_path_in_script=findFilePath(files[i],"outputfile");
				if (!input_path_in_script.equalsIgnoreCase("")&&!output_path_in_script.equalsIgnoreCase("")) break;
			}
		}
		
		if(!input_path_in_script.equalsIgnoreCase("")){
			
			Vector<String> in_path_toks = Utility.split(input_path_in_script, '\\');
			input_file_in_script = in_path_toks.get(in_path_toks.size()-1);
			Vector<String> in_file_toks = Utility.split(input_file_in_script, '.');
			input_filename_in_script = in_file_toks.get(0);
		}
		if(!output_path_in_script.equalsIgnoreCase("")){
			Vector<String> out_path_toks = Utility.split(output_path_in_script, '\\');
			output_file_in_script = out_path_toks.get(out_path_toks.size()-1);
			Vector<String> out_file_toks = Utility.split(output_file_in_script, '.');
			output_filename_in_script = out_file_toks.get(0);
		}
			
		for (int i=0; i<files.length; i++){
			if (files[i].isFile()){
				if(!input_path_in_script.equalsIgnoreCase(""))	replaceStringInScript(files[i],input_path_in_script, "%inputPath%");
				if(!output_path_in_script.equalsIgnoreCase(""))	replaceStringInScript(files[i],output_path_in_script, "%outputPath%");
				if(!input_file_in_script.equalsIgnoreCase(""))	replaceStringInScript(files[i],input_file_in_script, "%inputFile%");
				if(!output_file_in_script.equalsIgnoreCase(""))	replaceStringInScript(files[i],output_file_in_script, "%outputFile%");
				if(!input_filename_in_script.equalsIgnoreCase(""))	replaceStringInScript(files[i],input_filename_in_script, "%inputName%");
				if(!output_filename_in_script.equalsIgnoreCase(""))	replaceStringInScript(files[i],output_filename_in_script, "%outputName%");
			}
		}

	}
	
	
	
	/**
	 * loops over all input files to build the script - it assumes that the file #0 will have the "run" command
	 * @param scriptName name of output AHK script
	 * @param roadMapFolder input directory
	 **/
	public static void writeScript(String scriptName, String roadMapFolder){
		
		if(!roadMapFolder.endsWith("\\"))
			roadMapFolder+="\\";
		File folder = new File(roadMapFolder);
		String[] fs = folder.list();
		Vector<String> fileNames = new Vector<String>();
		for(String st:fs){
			fileNames.add(st);
		}
		Collections.sort(fileNames);
		File[] files = new File[fileNames.size()];
		for (int i=0; i<fileNames.size(); i++){
			files[i]=new File(roadMapFolder+fileNames.get(i));
		}

		replaceScriptFileInfo(files);
		
		for (int i=0; i<files.length; i++){
//			System.out.println(files[i].getAbsolutePath());
			if (files[i].isFile()){
				if (files[i].getName().charAt(0)=='0')
					startScript(scriptName,files[i]);
				else
					generateScript(scriptName,files[i]);
			}        
		}
		finishScript(scriptName);
	}
	
	/**
	 * generates the header for the script
	 * @param scriptName name of output AHK script
	 * @param roadMapFolder the directory where the "path" files can be found
	 **/
	public static void generateHeader(String scriptName, String roadMapFolder, String inputs, String domain){
		FileWriter fw;
		String format, formatJSON, swName;

		try{
			fw = new FileWriter(scriptName, true);

			if(!roadMapFolder.endsWith("\\"))
				roadMapFolder+="\\";
			format = roadMapFolder.substring(0, roadMapFolder.lastIndexOf('\\'));
			format= format.substring(format.lastIndexOf('\\')+1);
			formatJSON=generateFormatJSONString(format, roadMapFolder);
			swName = scriptName.substring(scriptName.lastIndexOf('\\')+1, scriptName.indexOf("_convert"));
			scriptComment("txt/json",fw, 0); //first line is for format: txt/xml/JSON
			scriptComment(swName,fw, 0); //second line is for SoftwareName(SWVersion)
			scriptComment(removeDoubleQuotes(domain),fw, 0); //third line is for domain: image, audio, video, etc
			scriptComment("",fw, 0); //fourth line is left blank for Software parameters
			scriptComment(removeDoubleQuotes(inputs),fw, 0); //fifth line is for input formats
			scriptComment("outputFormat:["+formatJSON+"]",fw, 0);

	    fw.close();
		} 
		catch (IOException e){
			e.printStackTrace();
		}
	}
	
	
	/**
	 * wrap call to scriptRun
	 * @param scriptName name of output AHK script
	 * @param f file with necessary RUN information
	 **/
	public static void startScript(String scriptName, File f){
		FileWriter fw;
		BufferedReader ins;
		String domain, inputs, run;
		try{
			fw = new FileWriter(scriptName, true);
	    ins = new BufferedReader(new FileReader(f));
			run=readLine(ins);
			run=advanceLine(run);
			domain = readLine(ins);
			domain = advanceLine(domain);
			inputs = readLine(ins);
			inputs = advanceLine(inputs);
			generateHeader(scriptName, f.getParent(), inputs, domain);
			scriptRun(run, fw, 0);
	    fw.close();
	    ins.close();
		} 
		catch (IOException e){
			e.printStackTrace();
		}
	}
	
	/**
	 * adds all initial info to AHK script
	 * @param line contains the SW name and path 
	 * @param fw file writer
	 **/
	public static void scriptRun(String line, FileWriter fw, int level){
		String swName, swPath;
		
		scriptWrite("curr_arg:=0", fw, level);
		scriptWrite("args_from_file :=0", fw, level);		
		scriptWrite("curr_file_line :=0", fw, level);
		scriptWrite("argFile:=LookupParam(\"argFile\")",fw, level);
		scriptWrite("l := StrLen(argFile)",fw, level);
		scriptWrite("if (l != 0)",fw, level);
		scriptWrite("{",fw, level);
		scriptWrite("args_from_file :=1", fw, level+1);
		scriptWrite("}",fw, level);

		
		scriptComment("input path is the first argument of script OR given by the tag inputFile",fw, level);
		scriptWrite("inputPath:=LookupParam(\"inputFile\")",fw, level);
		scriptWrite("l := StrLen(inputPath)",fw, level);
		scriptWrite("if (l = 0)",fw, level);
		scriptWrite("{",fw, level);
		scriptWrite("curr_arg:=curr_arg+1", fw, level+1);
		scriptWrite("inputPath:=%curr_arg%", fw, level+1);
		scriptWrite("}",fw, level);
		scriptComment("output path is the second argument of script OR given by the tag outputFile",fw, level);
		scriptWrite("outputPath:=LookupParam(\"outputFile\")",fw, level);
		scriptWrite("l := StrLen(outputPath)",fw, level);
		scriptWrite("if (l = 0)",fw, level);
		scriptWrite("{",fw, level);
		scriptWrite("curr_arg:=curr_arg+1", fw, level+1);
		scriptWrite("outputPath:=%curr_arg%", fw, level+1);
		scriptWrite("}",fw, level);
		
		advanceParam(fw, level);
		scriptWrite("",fw, level);
		
		if(debug==1){
			scriptComment("******************* debugging", fw, level);
			scriptWrite("inputPath:=\"C:\\Documents and Settings\\liana\\Desktop\\e.bmp\"", fw, level);
			scriptWrite("outputPath:=\"C:\\Documents and Settings\\liana\\Desktop\\e.jpg\"", fw, level);
			scriptComment("******************* debugging", fw, level);
		}
		
		scriptComment("initializing some variables", fw, level);
		scriptComment("Split input file path to get input file name with extension", fw, level);
		scriptWrite("SplitPath, inputPath, inputFile", fw, level);
		scriptComment("Split input file path to get input file extension", fw, level);
		scriptWrite("SplitPath, inputPath,,,inputExtension", fw, level);
		scriptComment("Split input file path to get input file name without extension", fw, level);
		scriptWrite("SplitPath, inputPath,,,,inputName", fw, level);
		scriptComment("Split output file path to get output file name with extension", fw, level);
		scriptWrite("SplitPath, outputPath, outputFile", fw, level);
		scriptComment("Split output file path to get output file extension", fw, level);
		scriptWrite("SplitPath, outputPath,,,outputExtension", fw, level);
		scriptComment("Split output file path to get input file name without extension", fw, level);
		scriptWrite("SplitPath, outputPath,,,,outputName", fw, level);
		
		
		
		scriptComment("set Title match to anywhere in the title (this is applied to all title matchings)\n", fw, level);
		scriptWrite("SetTitleMatchMode, 2", fw, level);
		scriptComment("run program if it is not already running", fw, level);
		scriptComment("looks for a window which title contains the SWName but not the word convert (because this is our script!)", fw, level);
		swName = nextWord(line);
		scriptWrite("WinShow, "+swName+",,convert", fw, level);
		scriptComment("shows window if it exists, otherwise it can be not found by mistake", fw, level);
		scriptWrite("IfWinExist, "+swName+",,convert", fw, level);
		scriptComment("activates the window found by the IfWinExist", fw, level+1);
		scriptWrite("\tWinActivate", fw, level);
		scriptWrite("else", fw, level);
		scriptComment("runs the program SWName", fw, level+1);
		line= advanceLine(line);
		swPath= nextWord(line);
		scriptWrite("\tRun, "+removeDoubleQuotes(swPath), fw, level);
		scriptWrite("",fw, level);
		scriptWrite("",fw, level);
		
	}
	
	/**
	 * adds definition of used functions to the end of AHK script
	 * @param scriptName name of output AHK script
	 **/
	public static void finishScript(String scriptName){
		FileWriter fw;
		try{
			fw = new FileWriter(scriptName, true);
			scriptWrite("Return", fw, 0);
			scriptWrite("", fw, 0);
	    	defineAdvanceParam(fw, 0);
	    	defineWin(fw, 0);
	    	defineLookupParam(fw,0);
	    	fw.close();
		} 
		catch (IOException e){
			e.printStackTrace();
		}
	}
	
	/**
	 * searches for params in "path" files and adds necessary AHK code when found
	 * @param roadMapFile name of file being searched
	 **/
	public static String prepareExtraParams(File roadMapFile){
		int b=0;
		String str;
		BufferedReader bf;
		List<String> resList = new ArrayList<String>();
		
		try{
			bf = new BufferedReader(new FileReader(roadMapFile));
			while((str=bf.readLine())!=null){
				if (!nextWord(str).equalsIgnoreCase("param"))
					continue;
				str = advanceLine(str);
				str = advanceLine(str);
				str = nextWord(str);
				resList.add(str);
			}
			bf.close();
		} catch (Exception e){
			e.printStackTrace();
		}
		str = "";
		for (Iterator<String> i = resList.iterator(); i.hasNext();){
			if (b==0){
				b=1;
				str = "if ( (curr_param_name="+i.next()+") ";
			}
			else
				str = str + "or (curr_param_name="+i.next()+") ";
		}
		if (b !=0 ) str = str+")";
		
		return str;
	}
	
	/**
	 * wraps calls to generateScriptRec, so optional actions may be skipped if the param was not selected
	 * @param scriptName name of output AHK script
	 * @param roadMapFile name of file being processed
	 **/
	public static void generateScript(String scriptName, File roadMapFile){
		BufferedReader ins;
		FileWriter fw;
		String f, rm;
		try{
				fw = new FileWriter(scriptName, true);
	    	ins = new BufferedReader(new FileReader(roadMapFile));
	    	
	    	//remove comments for adding the option of not performing related steps
	    	//if the parameters are not being used - this was the 'always' option of 'obligatory steps' in the AHKPathRecorder
	    	
//	    	f=roadMapFile.getName();
//	    	f=f.substring(f.indexOf('_')+1);	    	
//
//	    	if (f.charAt(0)=='0'){
//	    		rm = prepareExtraParams(roadMapFile);
//	    		if (!rm.isEmpty()){
//		    		scriptWrite(rm,fw,0);
//		    		scriptWrite("{",fw,0);
//		    		generateScriptRec(ins, fw, 1, "");
//		    		scriptWrite("}",fw,0);
//	    		}
//	    		else return;
//	    	}
//	    	else
	    		generateScriptRec(ins, fw, 0, "");
	   		ins.close();
			fw.close();
		} 
		catch (IOException e){
			e.printStackTrace();
		}
	}

	/**
	 * generates the AHK script
	 * @param ins the input buffer
	 * @param fw the file writer
	 * @param level nesting level for organized indentation of output file
	 * @param currWindow the window description to be added to AHK command 
	 **/
	public static void generateScriptRec(BufferedReader ins, FileWriter fw, int level, String currWindow){
		String line, command;
	    try {
	    	while((line=readLine(ins)) != null){
	    		if (line.isEmpty()){
	    			continue;
	    		}
	    		line=line.trim();
	    		if (line.charAt(0)=='#'){
	    			return;
	    		}
	    		command = nextWord(line);
	    		line= advanceLine(line);
	    		if (command.equalsIgnoreCase("comment")){
	    			scriptComment(line, fw, level);
	    		}
	    		else if(command.equalsIgnoreCase("win")){
	    			currWindow=scriptWin(line, fw, level);
	    		}
	    		else if(command.equalsIgnoreCase("menu")){
	    			scriptMenu(line, fw, level, currWindow);
	    		}
	    		else if(command.equalsIgnoreCase("insert")){
	    			scriptInsert(line, fw, level, currWindow);
	    		}
	    		else if(command.equalsIgnoreCase("click")){
	    			scriptClick(line, fw, level, currWindow);
	    		}
	    		else if(command.equalsIgnoreCase("select")){
	    			scriptSelect(line, fw, level, currWindow);
	    		}
	    		else if(command.equalsIgnoreCase("choose")){
	    			scriptChoose(line, fw, level, currWindow);
	    		}
	    		else if(command.equalsIgnoreCase("scrollbar")){
	    			scriptScrollbar(line, fw, level, currWindow);
	    		}
	    		else if(command.equalsIgnoreCase("wait")){
	    			scriptWait(line, fw, level, currWindow);
	    		}
	    		else if(command.equalsIgnoreCase("savetext")){
	    			scriptSaveText(line, fw, level, currWindow);
	    		}
	    		else if(command.equalsIgnoreCase("param")){
	    			scriptInputParam(line, fw, ins, level, currWindow);
	    		}
	    	}
		}catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	
	//TODO debug wait options in the generated script
	/**
	 * adds AHK commands that create a "wait" in the AHK script execution
	 * @param line contains command details
	 * @param fw the file writer
	 * @param level nesting level for organized indentation of output file
	 * @param currWindow the window description to be added to AHK command
	 **/
	public static void scriptWait(String line, FileWriter fw, int level, String currWindow){
		String command, title="";
		command = nextWord(line);
		line = advanceLine(line);
		if (command.equalsIgnoreCase("text")){
			scriptComment("waiting for text "+line, fw, level);
			title="found := 0";
			scriptWrite(title, fw, level);
			title="while (found = 0)";
			scriptWrite(title, fw, level);
			scriptWrite("{", fw, level);
			title="WinGetText, text";
			if (!currWindow.isEmpty())
				title+=", "+currWindow;
			scriptWrite(title, fw, level+1);
			title="found:= InStr(text, "+formatToken("",nextWord(line),"")+")";
			scriptWrite(title, fw, level+1);
			scriptWrite("}", fw, level);
		}
		else if (command.equalsIgnoreCase("status")){
			scriptComment("waiting for text "+line+" in status bar", fw, level);
			title+="StatusBarWait, "+formatToken("",nextWord(line),",,,");
			if (!currWindow.isEmpty())
				title+=", "+currWindow;
			scriptWrite(title, fw, level);
		}
		else if (command.equalsIgnoreCase("image")){
			scriptComment("waiting for image "+line, fw, level);
			title="ImageSearch, FoundX, FoundY, 0, 0, A_ScreenWidth, A_ScreenHeight, "+formatToken("",nextWord(line),"");	
		}
		else if (command.equalsIgnoreCase("time")){
			scriptComment("sleeping for "+line+" milliseconds", fw, level);
			scriptWrite("Sleep, "+formatToken("",nextWord(line),""), fw, level);
		}
	}
	
	/**
	 * adds a new param to the AHK script
	 * @param line contains command details
	 * @param fw the file writer
	 * @param ins input buffer
	 * @param level nesting level for organized indentation of output file
	 * @param currWindow the window description to be added to AHK command
	 **/
	public static void scriptInputParam(String line, FileWriter fw, BufferedReader ins, int level, String currWindow){
		//first line is always: param ControlType ParamName
		String controlType, paramName;
		controlType = formatToken("",nextWord(line),"");
		line=advanceLine(line);
		paramName = nextWord(line);

		scriptWrite("if (curr_param_name = "+paramName+")", fw, level);
		scriptWrite("{", fw, level);
		scriptWrite("local_param_value := curr_param_value", fw, level+1);
		advanceParam(fw, level+1);
		line=readLine(ins);
		
		if(controlType.equalsIgnoreCase("Menu")){
			scriptParamMenu(line, fw, ins, level+1, currWindow);
		}
		else if (controlType.equalsIgnoreCase("Button")){
			scriptParamButton(line, fw, ins, level+1, currWindow);
		}
		else if (controlType.equalsIgnoreCase("UserInput")){
			scriptParamUserInput(line, fw, ins, level+1, currWindow);
		}
		else if (controlType.equalsIgnoreCase("Scrollbar")){
			scriptParamScroll(line, fw, ins, level+1, currWindow);
		}
		else if (controlType.equalsIgnoreCase("Checkbox")){
			scriptParamCheckbox(line, fw, ins, level+1, currWindow);
		}
		else if (controlType.equalsIgnoreCase("Dropdown")){
			scriptParamDropdownMenu(line, fw, ins, level+1, currWindow);
		}
		else if (controlType.equalsIgnoreCase("SaveText")){
			scriptParamSaveText(line, fw, ins, level+1, currWindow);
		}
		scriptWrite("}", fw, level);
	}
	

	/**
	 * adds a "save text" command to the AHK script that will be executed if the param is selected
	 * @param line contains command details
	 * @param fw the file writer
	 * @param ins input buffer
	 * @param level nesting level for organized indentation of output file
	 * @param currWindow the window description to be added to AHK command
	 **/
	public static void scriptParamSaveText(String line, FileWriter fw, BufferedReader ins, int level, String currWindow){
		scriptWrite("if (local_param_value = \"true\")", fw, level);
		scriptWrite("{", fw, level);
		
		for (; line.isEmpty() || nextWord(line).charAt(0)!='#'; line = readLine(ins)){
			if (nextWord(line).isEmpty())
				continue;
			if(nextWord(line).equalsIgnoreCase("win")){
				currWindow=scriptWin(advanceLine(line), fw, level+1);
			}
			else if(nextWord(line).equalsIgnoreCase("savetext")){
				scriptSaveText(advanceLine(line), fw, level+1, currWindow);
			}
			else if(nextWord(line).equalsIgnoreCase("comment")){
				scriptComment(advanceLine(line), fw, level+1);
			}
		}
			
		if(line.charAt(0)=='#'){
			line=readLine(ins);
			generateScriptRec(ins, fw, level+1, currWindow);
		}

		scriptWrite("}", fw, level);
		
	}
	
	
	/**
	 * adds to the AHK script commands that choose an item of a dropdown menu according to the param selection
	 * @param line contains command details
	 * @param fw the file writer
	 * @param ins input buffer
	 * @param level nesting level for organized indentation of output file
	 * @param currWindow the window description to be added to AHK command
	 **/
	public static void scriptParamDropdownMenu(String line, FileWriter fw, BufferedReader ins, int level, String currWindow){
		String line_to_send="", optionNum, optionText;
		int method=1;
		//line should be a win command, but let's check it just to be sure
		//escapes any empty lines
		
		for (; line.isEmpty() || nextWord(line).charAt(0)!='#'; line = readLine(ins)){
			if (nextWord(line).isEmpty())
				continue;
			if(nextWord(line).equalsIgnoreCase("win")){
				currWindow=scriptWin(advanceLine(line), fw, level);
			}
			else if(nextWord(line).equalsIgnoreCase("userchoose")){
				line_to_send = advanceLine(line);//will have the control name
				line=advanceLine(line);
				if (nextWord(line).equalsIgnoreCase("method")){
					line=advanceLine(line);
					method=Integer.parseInt(nextWord(line));
				}
			}
			else if(nextWord(line).equalsIgnoreCase("comment")){
				scriptComment(advanceLine(line), fw, level);
			}
		}
			
		for(;!nextWord(line).equalsIgnoreCase("END");line=readLine(ins)){
			if(line.isEmpty()) continue;
			if(nextWord(line).equalsIgnoreCase("comment")){
				scriptComment(advanceLine(line), fw, level);
				continue;
			}
			if(line.charAt(0)=='#'){//we should be here in the first time we enter the loop, this is the first of the options
				line=readLine(ins);//we have now: "option_text" "option_num"
				optionText=nextWord(line);
				line=advanceLine(line);
				optionNum=nextWord(line);
				scriptWrite("if (local_param_value = \""+formatToken("",optionText,"")+"\"){", fw, level);	
				scriptComment(formatToken("",optionText,"")+formatToken(" is item num ",optionNum,""), fw, level+1);
				if (method==1)
					scriptChoose(line_to_send+" "+optionNum, fw, level+1, currWindow);
				else
					scriptChoose(line_to_send+" "+optionText, fw, level+1, currWindow);
				generateScriptRec(ins, fw, level+1, currWindow);
				scriptWrite("}", fw, level);
			}
			else{//any other options returning from generateScriptRec
				optionText=nextWord(line);
				line=advanceLine(line);
				optionNum=nextWord(line);
				scriptWrite("else if (local_param_value = \""+formatToken("",optionText,"")+"\"){", fw, level);
				scriptComment(formatToken("",optionText,"")+formatToken(" is item num ",optionNum,""), fw, level+1);
				if (method==1)
					scriptChoose(line_to_send+" "+optionNum, fw, level+1, currWindow);
				else
					scriptChoose(line_to_send+" "+optionText, fw, level+1, currWindow);
				generateScriptRec(ins, fw, level+1, currWindow);
				scriptWrite("}", fw, level);
			}
			
		}

		
	}
	
	/**
	 * adds to the AHK script commands that check/unchek a checkbox according to the param selection
	 * @param line contains command details
	 * @param fw the file writer
	 * @param ins input buffer
	 * @param level nesting level for organized indentation of output file
	 * @param currWindow the window description to be added to AHK command
	 **/
	public static void scriptParamCheckbox(String line, FileWriter fw, BufferedReader ins, int level, String currWindow){
		String line_to_send="", token;
		
		for (; line.isEmpty() || nextWord(line).charAt(0)!='#'; line = readLine(ins)){
			if (nextWord(line).isEmpty())
				continue;
			if(nextWord(line).equalsIgnoreCase("win")){
				currWindow=scriptWin(advanceLine(line), fw, level);
			}
			else if(nextWord(line).equalsIgnoreCase("checkbox")){
				line_to_send = advanceLine(line);//will have the control name
			}
			else if(nextWord(line).equalsIgnoreCase("comment")){
				scriptComment(advanceLine(line), fw, level);
			}
		}
	
		for(;!nextWord(line).equalsIgnoreCase("END");line=readLine(ins)){
			if(line.isEmpty()) continue;
			if(nextWord(line).equalsIgnoreCase("comment")){
				scriptComment(advanceLine(line), fw, level);
				continue;
			}
			if(line.charAt(0)=='#'){//we should be here in the first time we enter the loop, this is the first of the options
				line=readLine(ins);//we have now a "value"
				token=nextWord(line);
				scriptWrite("if (local_param_value = \""+formatToken("",token,"")+"\"){", fw, level);
				scriptSelect(line_to_send+" "+token, fw, level+1, currWindow);
				generateScriptRec(ins, fw, level+1, currWindow);
				scriptWrite("}", fw, level);
			}
			else{//any other options returning from generateScriptRec
				token=nextWord(line);
				scriptWrite("else if (local_param_value = \""+formatToken("",token,"")+"\"){", fw, level);
				scriptSelect(line_to_send+" "+token, fw, level+1, currWindow);
				generateScriptRec(ins, fw, level+1, currWindow);
				scriptWrite("}", fw, level);
			}	
		}

	}

	
	/**
	 * adds to the AHK script commands that move a scrollbar according to the param selection
	 * @param line contains command details
	 * @param fw the file writer
	 * @param ins input buffer
	 * @param level nesting level for organized indentation of output file
	 * @param currWindow the window description to be added to AHK command
	 **/
	public static void scriptParamScroll(String line, FileWriter fw, BufferedReader ins, int level, String currWindow){
	
		for (; line.isEmpty() || nextWord(line).charAt(0)!='#'; line = readLine(ins)){
			if (nextWord(line).isEmpty())
				continue;
			if(nextWord(line).equalsIgnoreCase("win")){
				currWindow=scriptWin(advanceLine(line), fw, level);
			}
			else if(nextWord(line).equalsIgnoreCase("userscrollbar")){
				line = advanceLine(line);
				line = "\"local_param_value\" "+line;
				scriptScrollbar(line, fw, level, currWindow);
			}
			else if(nextWord(line).equalsIgnoreCase("comment")){
				scriptComment(advanceLine(line), fw, level);
			}
		}	
		
		//line should now be # ....
		if(line.charAt(0)=='#'){
			line=readLine(ins);
			generateScriptRec(ins, fw, level, currWindow);
		}

	}	
	
	/**
	 * adds to the AHK script commands that insert text into an "edit box" according to the param selection
	 * @param line contains command details
	 * @param fw the file writer
	 * @param ins input buffer
	 * @param level nesting level for organized indentation of output file
	 * @param currWindow the window description to be added to AHK command
	 **/
	public static void scriptParamUserInput(String line, FileWriter fw, BufferedReader ins, int level, String currWindow){
		
		for (; line.isEmpty() || nextWord(line).charAt(0)!='#'; line = readLine(ins)){
			if (nextWord(line).isEmpty())
				continue;
			if(nextWord(line).equalsIgnoreCase("win")){
				currWindow=scriptWin(advanceLine(line), fw, level);
			}
			else if(nextWord(line).equalsIgnoreCase("userinput")){
				line=advanceLine(line);
				line = "local_param_value "+line;
				scriptInsert(line, fw, level, currWindow);
			}
			else if(nextWord(line).equalsIgnoreCase("comment")){
				scriptComment(advanceLine(line), fw, level);
			}
		}
		
		if(line.charAt(0)=='#'){
			line=readLine(ins);
			generateScriptRec(ins, fw, level, currWindow);
		}

		
	}
	
	
	/**
	 * adds to the AHK script commands that click (or not) a button according to the param selection
	 * @param line contains command details
	 * @param fw the file writer
	 * @param ins input buffer
	 * @param level nesting level for organized indentation of output file
	 * @param currWindow the window description to be added to AHK command
	 **/
	public static void scriptParamButton(String line, FileWriter fw, BufferedReader ins, int level, String currWindow){
		scriptWrite("if (local_param_value = \"true\")", fw, level);
		scriptWrite("{", fw, level);
		
		for (; line.isEmpty() || nextWord(line).charAt(0)!='#'; line = readLine(ins)){
			if (nextWord(line).isEmpty())
				continue;
			if(nextWord(line).equalsIgnoreCase("win")){
				currWindow=scriptWin(advanceLine(line), fw, level+1);
			}
			else if(nextWord(line).equalsIgnoreCase("click")){
				scriptClick(advanceLine(line), fw, level+1, currWindow);
			}
			else if(nextWord(line).equalsIgnoreCase("comment")){
				scriptComment(advanceLine(line), fw, level+1);
			}
		}
			
		if(line.charAt(0)=='#'){
			line=readLine(ins);
			generateScriptRec(ins, fw, level+1, currWindow);
		}

		scriptWrite("}", fw, level);
		
	}
	
	
	/**
	 * adds to the AHK script commands that choose an item of a menu according to the param selection
	 * @param line contains command details
	 * @param fw the file writer
	 * @param ins input buffer
	 * @param level nesting level for organized indentation of output file
	 * @param currWindow the window description to be added to AHK command
	 **/
	public static void scriptParamMenu(String line, FileWriter fw, BufferedReader ins, int level, String currWindow){
		scriptWrite("if (local_param_value = \"true\")", fw, level);
		scriptWrite("{", fw, level);
		
		
		for (; line.isEmpty() || nextWord(line).charAt(0)!='#'; line = readLine(ins)){
			if (nextWord(line).isEmpty())
				continue;
			if(nextWord(line).equalsIgnoreCase("win")){
				currWindow=scriptWin(advanceLine(line), fw, level+1);
			}
			else if(nextWord(line).equalsIgnoreCase("menu")){
				scriptMenu(advanceLine(line), fw, level+1, currWindow);
			}
			else if(nextWord(line).equalsIgnoreCase("comment")){
				scriptComment(advanceLine(line), fw, level+1);
			}
		}
				
		if(line.charAt(0)=='#'){
			line=readLine(ins);
			generateScriptRec(ins, fw, level+1, currWindow);
		}

		scriptWrite("}", fw, level);
		
	}

	
	/**
	 * adds to the AHK script a call to Win() which will (in runtime) wait for a window and show it
	 * @param line contains command details
	 * @param fw the file writer
	 * @param level nesting level for organized indentation of output file
	 **/
	public static String scriptWin(String line, FileWriter fw, int level){
		String title, token, currWindow="";
		title="";
		while(!line.isEmpty()){
			token= nextWord(line);
			title+=formatToken("", token, "");
			line=advanceLine(line);
		}
		currWindow = title;
		scriptWrite("Win(\""+title+"\")", fw, level);
		
		return currWindow;
	}

	
	/**
	 * adds to the AHK script Win function definition - this function makes the AHK script wait for a window to show
	 * @param fw the file writer
	 * @param level nesting level for organized indentation of output file
	 **/
	public static void defineWin(FileWriter fw, int level){
		scriptWrite("", fw, level);
		scriptWrite("Win(WinTitle){", fw, level);
		scriptWrite("WinShow, %WinTitle%", fw, level+1);
		scriptWrite("WinWait, %WinTitle%", fw, level+1);
		scriptWrite("}", fw, level);
	}

	
	/**
	 * adds to the AHK script LookupParam function definition - this function checks whether a specific param is present in the script args
	 * @param fw the file writer
	 * @param level nesting level for organized indentation of output file
	 **/
	public static void defineLookupParam(FileWriter fw, int level){
		scriptWrite("", fw, level);
		scriptWrite("LookupParam(ParamToSearch)", fw, level);
		scriptWrite("{", fw, level);
		scriptWrite("global", fw, level+1);
		scriptWrite("Loop %0%", fw, level+1);
		scriptWrite("{", fw, level+1);
		scriptWrite("ans := LookupParamSimple(ParamToSearch)", fw, level+2);
		scriptWrite("if (StrLen(ans)!=0)", fw, level+2);
		scriptWrite("return ans", fw, level+3);
		scriptWrite("}", fw, level+1);
		scriptWrite("if (args_from_file !=0)", fw, level+1);
		scriptWrite("{", fw, level+1);
		scriptWrite("ans := LookupParamFile(ParamToSearch)", fw, level+2);
		scriptWrite("return ans", fw, level+2);
		scriptWrite("}", fw, level+1);
		scriptWrite("return \"\"", fw, level+1);
		scriptWrite("}", fw, level);

		scriptWrite("", fw, level);
		scriptWrite("LookupParamSimple(ParamToSearch)", fw, level);
		scriptWrite("{", fw, level);
		scriptWrite("global", fw, level+1);
		scriptWrite("AutoTrim, On", fw, level+1);
		scriptWrite("ans :=\"\"", fw, level+1);
		scriptWrite("Loop %0%", fw, level+1);
		scriptWrite("{", fw, level+1);
		scriptWrite("e := %A_Index%", fw, level+2);
		scriptWrite("e = %e%", fw, level+2);
		scriptWrite("StringSplit, lookup, e, =", fw, level+2);
		scriptWrite("lookup1 = %lookup1%", fw, level+2);
		scriptWrite("if (ParamToSearch = lookup1)", fw, level+2);
		scriptWrite("{", fw, level+2);
		scriptWrite("lookup2 = %lookup2%", fw, level+3);
		scriptWrite("ans := lookup2", fw, level+3);
		scriptWrite("lookup2 :=\"\"", fw, level+3);
		scriptWrite("return ans", fw, level+3);
		scriptWrite("}", fw, level+2);
		scriptWrite("}", fw, level+1);
		scriptWrite("return \"\"", fw, level+1);
		scriptWrite("}", fw, level);

		scriptWrite("", fw, level);
		scriptWrite("LookupParamFile(ParamToSearch)", fw, level);
		scriptWrite("{", fw, level);
		scriptWrite("global", fw, level+1);
		scriptWrite("AutoTrim, On", fw, level+1);
		scriptWrite("ans :=\"\"", fw, level+1);
		scriptWrite("Loop, read, %argFile%", fw, level+1);
		scriptWrite("{", fw, level+1);
		scriptWrite("line := A_LoopReadLine", fw, level+2);
		scriptWrite("line = %line%", fw, level+2);
		scriptWrite("StringSplit, lookup, line, =", fw, level+2);
		scriptWrite("lookup1 = %lookup1%", fw, level+2);
		scriptWrite("if (ParamToSearch = lookup1)", fw, level+2);
		scriptWrite("{", fw, level+2);
		scriptWrite("lookup2 = %lookup2%", fw, level+3);
		scriptWrite("ans := lookup2", fw, level+3);
		scriptWrite("lookup2 :=\"\"", fw, level+3);
		scriptWrite("return ans", fw, level+3);
		scriptWrite("}", fw, level+2);
		scriptWrite("}", fw, level+1);
		scriptWrite("return \"\"", fw, level+1);
		scriptWrite("}", fw, level);
	}
	
	/**
	 * adds to the AHK script a call to AdvanceParam which gets the AHK script to move on to the next param in args list (in runtime)
	 * @param fw the file writer
	 * @param level nesting level for organized indentation of output file
	 **/
	public static void advanceParam(FileWriter fw, int level){
		scriptWrite("AdvanceParam()", fw, level);
	}
		
	/**
	 * adds to the AHK script AdvanceParam function definition - this function makes the AHK script to move on to the next param in args list (in runtime)
	 * @param fw the file writer
	 * @param level nesting level for organized indentation of output file
	 **/
	public static void defineAdvanceParam(FileWriter fw, int level){
		scriptWrite("", fw, level);
		scriptWrite("AdvanceParam()", fw, level);
		scriptWrite("{", fw, level);
		scriptWrite("global", fw, level+1);
		scriptWrite(";zeros param:", fw, level+1);
		scriptWrite("curr_arg_line := \"\"", fw, level+1);
		scriptWrite("curr_param_name := \"\"", fw, level+1);
		scriptWrite("curr_param_value := \"\"", fw, level+1);
		scriptWrite("if (args_from_file =0)", fw, level+1);
		scriptWrite("{", fw, level+1);
		scriptWrite("AdvanceParamSimple()", fw, level+2);
		scriptWrite("}", fw, level+1);
		scriptWrite("else", fw, level+1);
		scriptWrite("{", fw, level+1);
		scriptWrite("AdvanceParamFile()", fw, level+2);
		scriptWrite("}", fw, level+1);
		scriptWrite("}", fw, level);
		
		scriptWrite("", fw, level);
		scriptWrite("AdvanceParamFile()", fw, level);
		scriptWrite("{", fw, level);
		scriptWrite("global", fw, level+1);
		scriptWrite("AutoTrim, On", fw, level+1);
		scriptWrite(";advances param:", fw, level+1);
		scriptWrite("curr_arg:=curr_arg+1", fw, level+1);
		scriptWrite("loop", fw, level+1);
		scriptWrite("{", fw, level+1);
		scriptWrite("curr_file_line:=curr_file_line+1", fw, level+2);
		scriptWrite("FileReadLine, curr_arg_line, %argFile%, %curr_file_line%", fw, level+2);
		scriptWrite("el:= ErrorLevel", fw, level+2);
		scriptWrite("len:=StrLen(curr_arg_line)", fw, level+2);
		scriptWrite("if (el!=0 or len!=0)", fw, level+2);
		scriptWrite("break", fw, level+3);
		scriptWrite("}", fw, level+1);
		scriptWrite("if (StrLen(curr_arg_line)!=0)", fw, level+1);
		scriptWrite("{", fw, level+1);
		scriptWrite("StringSplit, outs, curr_arg_line, =", fw, level+2);
		scriptWrite("curr_param_name := outs1", fw, level+2);
		scriptWrite("curr_param_name = %curr_param_name%", fw, level+2);
		scriptWrite("outs1 := \"\"", fw, level+2);
		scriptWrite("curr_param_value := outs2", fw, level+2);
		scriptWrite("curr_param_value = %curr_param_value%", fw, level+2);
		scriptWrite("outs2 :=\"\"", fw, level+2);
		scriptWrite("}", fw, level+1);
		scriptWrite("}", fw, level);
	
		scriptWrite("", fw, level);
		scriptWrite("AdvanceParamSimple()", fw, level);
		scriptWrite("{", fw, level);
		scriptWrite("global", fw, level+1);
		scriptWrite("AutoTrim, On", fw, level+1);
		scriptWrite(";advances param:", fw, level+1);
		scriptWrite("curr_arg:=curr_arg+1", fw, level+1);
		scriptWrite("if (curr_arg <= %0%)", fw, level+1);
		scriptWrite("{", fw, level+1);
		scriptWrite("curr_arg_line := %curr_arg%", fw, level+2);
		scriptWrite("StringSplit, outs, curr_arg_line, =", fw, level+2);
		scriptWrite("curr_param_name := outs1", fw, level+2);
		scriptWrite("curr_param_name = %curr_param_name%", fw, level+2);
		scriptWrite("outs1 := \"\"", fw, level+2);
		scriptWrite("curr_param_value := outs2	", fw, level+2);
		scriptWrite("curr_param_value = %curr_param_value%	", fw, level+2);	
		scriptWrite("outs2 := \"\"", fw, level+2);
		scriptWrite("}", fw, level+1);
		scriptWrite("}", fw, level);
	}
	
	
	/**
	 * not currently in use
	 * adds functionality to AHK script to deal with window pop ups that may or may not appear
	 * @param line contains command details
	 * @param fw the file writer
	 * @param ins input buffer
	 * @param level nesting level for organized indentation of output file
	 * @param currWindow the window description to be added to AHK command 
	 **/
	public static void scriptIfWin(String line, FileWriter fw, String currWindow, BufferedReader ins, int level){
		String token;
		token= nextWord(line);//name of window that popped-up
		line=advanceLine(line);
		
		try{
			scriptWrite("Sleep, 100", fw, level);
			scriptWrite("IfWinExist, "+formatToken("",token,"")+"", fw, level);
			scriptWrite("{", fw, level);
			generateScriptRec(ins, fw, level+1, currWindow);
			scriptWrite("}", fw, level);
		} catch (Exception e){
			e.printStackTrace();
		}
	}
	
	
	/**
	 * adds to the AHK script commands that move a scrollbar based on the definitions in the input file
	 * @param line contains command details
	 * @param fw the file writer
	 * @param level nesting level for organized indentation of output file
	 * @param currWindow the window description to be added to AHK command	 
	 **/
	public static void scriptScrollbar(String line, FileWriter fw, int level, String currWindow){
		String val, token, title="";
		val=nextWord(line);//"chosenvalue" 
		line=advanceLine(line);//"SysListView321" minRange "minnum" maxRange "maxnum"
		token= nextWord(line);//"SysListView321"
		
		title+="ControlSend"+formatToken(", ",token,", ");
		line=advanceLine(line);//minRange "minnum" maxRange "maxnum"
		if (nextWord(line).equalsIgnoreCase("minRange")){
			line=advanceLine(line);//"minnum" maxRange "maxnum"
			scriptWrite("min_range := "+formatToken("",nextWord(line),""), fw, level);
			line=advanceLine(line);//maxRange "maxnum"
		}
		else{
			scriptWrite("min_range := 0", fw, level);
		}
		if (nextWord(line).equalsIgnoreCase("maxRange")){
			line=advanceLine(line);//"maxnum"
			scriptWrite("max_range := "+formatToken("",nextWord(line),""), fw, level);
		}
		else{
			scriptWrite("max_range := 100", fw, level);
		}
		scriptWrite("value := "+formatToken("",val,""), fw, level);
		scriptWrite("left_clicks := max_range - min_range", fw, level);
		scriptWrite("right_clicks := value - min_range", fw, level);
		scriptWrite("Loop, %left_clicks%", fw, level);
		scriptWrite(title+"{Left}"+(currWindow.isEmpty()? "":", "+currWindow), fw, level+1);
		scriptWrite("Loop, %right_clicks%", fw, level);
		scriptWrite(title+"{Right}"+(currWindow.isEmpty()? "":", "+currWindow), fw, level+1);
	}
	

	/**
	 * adds to the AHK script commands that choose an item from a dropdown menu based on the definitions in the input file
	 * @param line contains command details
	 * @param fw the file writer
	 * @param level nesting level for organized indentation of output file
	 * @param currWindow the window description to be added to AHK command	 
	 **/
	public static void scriptChoose(String line, FileWriter fw, int level, String currWindow){
		String title="", control, item;
		int method=1;
		if (nextWord(line).equalsIgnoreCase("method")){
			line=advanceLine(line);
			method=Integer.parseInt(nextWord(line));
			line=advanceLine(line);
		}
		control= nextWord(line);
		line=advanceLine(line);
		item= nextWord(line);
		switch (method){
			case 1:
				title+="Control, Choose"+formatToken(", ",item,"")+formatToken(", ",control,"");			
				break;
			case 2:
				title+="Control, ChooseString"+formatToken(", ",item,"")+formatToken(", ",control,"");
				break;
			case 3:
				title+="ControlSendraw"+formatToken(", ",control,"")+formatToken(", ",item,"");
				break;
		}
		if (!currWindow.isEmpty()) title+=", "+currWindow;
		scriptWrite(title, fw, level);
	}
	
	
	/**
	 * adds to the AHK script commands that choose a menu item based on the definitions in the input file
	 * @param line contains command details
	 * @param fw the file writer
	 * @param level nesting level for organized indentation of output file
	 * @param currWindow the window description to be added to AHK command	 
	 **/
	public static void scriptMenu(String line, FileWriter fw, int level, String currWindow){
		String title, token;
		title="WinMenuSelectItem,";
		if (!currWindow.isEmpty()) title+=currWindow;
		title+=",";
		while(!line.isEmpty()){
			token= nextWord(line);
			title+=formatToken(", ",token," ");
			line=advanceLine(line);
		}
		scriptComment("selects the desired menu item", fw, level);
		scriptWrite(title, fw, level);
		
	}
	
	
	/**
	 * adds to the AHK script commands that click a button based on the definitions in the input file
	 * @param line contains command details
	 * @param fw the file writer
	 * @param level nesting level for organized indentation of output file
	 * @param currWindow the window description to be added to AHK command	 
	 **/
	public static void scriptClick(String line, FileWriter fw, int level, String currWindow){
		String title;
		title="ControlClick";
		title+=formatToken(", ",nextWord(line),"");
		if (!currWindow.isEmpty())
			title+=", "+currWindow;
		scriptComment("clicks the button", fw, level);
		scriptWrite(title, fw, level);
		
	}
	
	
	/**
	 * adds to the AHK script commands that saves text to a file based on the definitions in the input file
	 * @param line contains command details
	 * @param fw the file writer
	 * @param level nesting level for organized indentation of output file
	 * @param currWindow the window description to be added to AHK command	 
	 **/
	public static void scriptSaveText(String line, FileWriter fw, int level, String currWindow){
		String title, token;
		title="ControlGetText, tmp_res";
		token= nextWord(line);//control
		title+=formatToken(", ", token, "");
		if (!currWindow.isEmpty())
			title+=", "+currWindow;
		scriptComment("gets text into tmp_res", fw, level);
		scriptWrite(title, fw, level);
		title="FileAppend, %tmp_res%, ";
		line=advanceLine(line);
		token= nextWord(line);//file name
		title +=formatToken("",token,"");
		scriptComment("saves text from tmp_res into desired file", fw, level);
		scriptWrite(title, fw, level);
	}
	
	
	/**
	 * adds to the AHK script commands that insert text into an "edit box" based on the definitions in the input file
	 * @param line contains command details
	 * @param fw the file writer
	 * @param level nesting level for organized indentation of output file
	 * @param currWindow the window description to be added to AHK command	 
	 **/
	public static void scriptInsert(String line, FileWriter fw, int level, String currWindow){
		String title="", token="", textToInsert="";
		int method=1;
		textToInsert= nextWord(line);
		line=advanceLine(line);
		if (nextWord(line).equalsIgnoreCase("method")){
			line=advanceLine(line);
			token= nextWord(line);//method_num
			method=Integer.parseInt(token);
		}
		switch (method){
			case 1:
				title="ControlSetText";
				token=nextWord(line);
				token=formatToken(", ", token, "");//,control
				textToInsert=formatToken(", ", textToInsert, "");//,texttoinsert
				title+=token+textToInsert;//ControlSetText, control, textoinsert
				if (!currWindow.isEmpty())
					title+=", "+currWindow;//ControlSetText, control, textoinsert, window
				break;
			case 2:
				title="Control, EditPaste";
				token= nextWord(line);
				textToInsert=formatToken(", ", textToInsert, "");//,textoinsert
				token=formatToken(", ", token, "");//,control
				title+=textToInsert+token;//Control, EditPaste, textoinsert, control
				if (!currWindow.isEmpty())
					title+=", "+currWindow;//Control, EditPaste, textoinsert, control, win
				break;
			case 3:
				title="ControlSendRaw";
				token=nextWord(line);
				token=formatToken(", ", token, "");//,control
				textToInsert=formatToken(", ", textToInsert, "");//,texttoinsert
				title+=token+textToInsert;//ControlSendRaw, control, textoinsert
				if (!currWindow.isEmpty())
					title+=", "+currWindow;//ControlSendRaw, control, textoinsert, window
				break;
			case 4:
				title="SendInput {Raw}";
				textToInsert=formatToken("", textToInsert, "");//texttoinsert
				title+=textToInsert;//SendInput {Raw}texttoinsert
				break;	
		}
		
		scriptComment("inserts text into desired box", fw, level);
		scriptWrite(title, fw, level);
	}
	
	
	/**
	 * adds to the AHK script commands that check/uncheck a checkbox based on the definitions in the input file
	 * @param line contains command details
	 * @param fw the file writer
	 * @param level nesting level for organized indentation of output file
	 * @param currWindow the window description to be added to AHK command	 
	 **/
	public static void scriptSelect(String line, FileWriter fw, int level, String currWindow){
		String title, button, check;
		title="Control, ";
		button = nextWord(line);
		line=advanceLine(line);
		check=formatToken("",nextWord(line),"");
		if (check.equals("true"))
			title+="Check,";
		else
			title+="Uncheck,";
		title+=formatToken(", ",button,"");
		if (!currWindow.isEmpty())
			title+=", "+currWindow;
		scriptComment("checks/unchecks radio button/checkbox", fw, level);
		scriptWrite(title, fw, level);
		
	}
	

	
/*
	=======================================================================================================
 											JSON RELATED FUNCTIONS
	=======================================================================================================
*/		
	
	/**
	 * goes over the all "path" files to build the JSON string that defines the conversion to an output format
	 * @param format the conversion output format 
	 * @param folderName the directory that contains the "path" files
	 **/	
	public static String generateFormatJSONString(String format, String folderName){
		int count = 0;
		String str="", res="[";
		File folder = new File(folderName);
		File[] files = folder.listFiles();
		for (int i=0; i<files.length; i++) {
			if (files[i].isFile()){
				str=generateParameterJSONString(files[i]);
				if (!str.isEmpty()){
					if (count==0){
						res+=str;
						count++;
					}
					else
						res+=", "+str;
				}
			}        
		}
		res+="]";
		res="{'format':'"+format+"', 'paramSelections':"+res+"}";
		return res;
	}


	/**
	 * wraps rec function that goes over a file "path" to build the JSON string
	 * @param f a "path" file
	 * @return JSON string for file f
	 **/	
	public static String generateParameterJSONString(File f){
		BufferedReader bf;
		String text="";
		
		try {
			bf = new BufferedReader(new FileReader(f));
			text=generateJSONStringRec(bf);
			bf.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
		return text;
	}

	/**
	 * goes over a file "path" to build the JSON string based on the params defined in the file
	 * @param ins input buffer
	 * @return JSON string
	 **/	
	public static String generateJSONStringRec(BufferedReader ins){
		String line, command, token, text="";
		int paramCount=0;
	    try {
	    	while((line=ins.readLine()) != null){
	    		line=line.trim();
	    		if (line.isEmpty()){
	    			continue;
	    		}
	    		if (line.charAt(0)=='#'){ //next value or end 
	    			return text;
	    		}
	    		command = nextWord(line);
	    		//line= advanceLine(line);
	    		if(command.equalsIgnoreCase("param")){
	    			line=advanceLine(line);
					token = nextWord(line);
					line=advanceLine(line);
					
					if(token.equalsIgnoreCase("\"Menu\"") || token.equalsIgnoreCase("\"Button\"") || token.equalsIgnoreCase("\"Checkbox\"") || token.equalsIgnoreCase("\"Dropdown\"")){
						if (paramCount==0){
							text+="{";//ADD paramcounter e por , se nao for zero
							paramCount++;
						}
						else
							text+=", {";
						text+=	"'discreteParam':'true'";
						token = formatToken("", nextWord(line), "");
						line = advanceLine(line);
						if (!token.isEmpty())
							text +=", 'nameForDisplay':'"+token+"'";
						token = formatToken("", nextWord(line), "");
						if (!token.isEmpty())
							text +=", 'nameInSoftware':'"+token+"'";						
					}			
					else if(token.equalsIgnoreCase("\"UserInput\"") || token.equalsIgnoreCase("\"Scrollbar\"")){
						if (paramCount==0){
							text+="{";//ADD paramcounter e por , se nao for zero
							paramCount++;
						}
						else
							text+=", {";
						text+=	"'continuousParam':'true'";
						token = formatToken("", nextWord(line), "");
						line = advanceLine(line);
						if (!token.isEmpty())
							text +=", 'nameForDisplay':'"+token+"'";
						token = formatToken("", nextWord(line), "");
						if (!token.isEmpty())
							text +=", 'nameInSoftware':'"+token+"'";	
						
						while (!nextWord(line=ins.readLine()).equalsIgnoreCase("userinput")&&!nextWord(line).equalsIgnoreCase("userscrollbar"));
						line=advanceLine(line);//control minRange "minnum" maxRange "maxnum"
											   //or: method num control minRange "minnum" maxRange "maxnum"
						if (nextWord(line).equalsIgnoreCase("method")){
							line=advanceLine(line);//num control minRange "minnum" maxRange "maxnum"
							line=advanceLine(line);//control minRange "minnum" maxRange "maxnum"							
						}
						line=advanceLine(line);//minRange "minnum" maxRange "maxnum"
						if (nextWord(line).equalsIgnoreCase("minRange")||nextWord(line).equalsIgnoreCase("maxRange"))
							text +=", 'range':'true'";
						if (nextWord(line).equalsIgnoreCase("minRange")){
							line=advanceLine(line);//"minnum" maxRange "maxnum"
							text+=", 'minRange':"+formatToken("'",nextWord(line),"'");
							line=advanceLine(line);//maxRange "maxnum"
						}
						if (nextWord(line).equalsIgnoreCase("maxRange")){
							line=advanceLine(line);//"maxnum"
							text+=", 'maxRange':"+formatToken("'",nextWord(line),"'");
						}
					}
	    			text+=generateParam(ins)+"}";
	    		}
	    	}
		}catch (Exception e) {
			e.printStackTrace();
		}
	    return text;
	}


	/**
	 * generates JSON string for a param (including nested params)
	 * @param ins input buffer
	 * @return param JSON string
	 **/	
	public static String generateParam(BufferedReader ins){
		String line, token, possibleValues="", nestedParams="";
		
		try{
			line=ins.readLine();
			
			while ((line = ins.readLine()).isEmpty() || nextWord(line).charAt(0)!='#');
				
			for(;(line!=null)&&!nextWord(line).equalsIgnoreCase("END");line=ins.readLine()){
				if(line.isEmpty()||(line=line.trim()).isEmpty()) continue;
				if(line.charAt(0)=='#'){//we should be here in the first time we enter the loop, this is the first of the options
					while((line=ins.readLine()).isEmpty()||nextWord(line).equalsIgnoreCase("comment"));//we have now a "value"
					token=nextWord(line);
					possibleValues+=", 'possibleValues':[";
					if (!token.equalsIgnoreCase("any"))
						possibleValues+=formatToken("'",token,"'");
					nestedParams+=", 'nestedParams':[["+generateJSONStringRec(ins)+"]";
				}
				else if(line.charAt(0)=='\"'){//any other options returning from generateScriptRec
					token=nextWord(line);
					possibleValues+=", "+formatToken("'",token,"'");//AQUI
					nestedParams+=", ["+generateJSONStringRec(ins)+"]";
				}
			}			
			possibleValues+="]";
			nestedParams+="]";
		} catch(Exception e){e.printStackTrace();}

		return possibleValues+nestedParams;
	}

	
	
/*
	=======================================================================================================
 											GENERAL FUNCTIONS
	=======================================================================================================
*/	
	
	
	/**
	 * adds text to the AHK script file
	 * @param line contains the text to be added
	 * @param fw the file writer
	 * @param level nesting level for organized indentation of output file
	 **/
	public static void scriptWrite(String line, FileWriter fw, int level){
		String tabs="";
		while(level>0){
			tabs+="\t";
			level--;
		}
		try {
			fw.write(tabs+line+"\n");
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	
	/**
	 * adds a comment to the AHK script file
	 * @param line contains the comment to be added
	 * @param fw the file writer
	 * @param level nesting level for organized indentation of output file
	 **/
	public static void scriptComment(String line, FileWriter fw, int level){
		String tabs="";
		while(level>0){
			tabs+="\t";
			level--;
		}
		try {
			fw.write(tabs+";");
			for(;line!=null && !line.isEmpty();line=advanceLine(line))
				fw.write(nextWord(line)+' ');
			fw.write("\n");
		} catch (IOException e) {
			e.printStackTrace();
		}		
	}
	

	/**
	 * removes double quotes from a string (first and last chars)
	 * @param str string to be processed
	 **/
	public static String removeDoubleQuotes(String str){
		return str.substring(1,str.length()-1);
	}	
	
	
	/**
	 * returns the next word of a string
	 * @param str string to be processed
	 **/
	public static String nextWord(String str){
		if (str.isEmpty())
			return str;
		str=str.trim();
		if(str.indexOf(' ')==-1)
			return str;
		if (str.charAt(0)=='\"')
			return str.substring(0, str.indexOf('\"', 1)+1);
		else
			return str.substring(0, str.indexOf(' '));
	}

	
	/**
	 * advances a string so its first word is flushed
	 * @param str string to be processed
	 **/
	public static String advanceLine(String str){
		if (str==null || str.isEmpty()) return str;
		str=str.trim();
		if (str.indexOf(' ')==-1) return "";
		if (str.charAt(0)=='\"'){
			if (str.indexOf(' ', str.indexOf('\"', 1))==-1) 
				return "";
			return str.substring(str.indexOf(' ', str.indexOf('\"', 1))+1).trim();
		}
		return str.substring(str.indexOf(' ')+1).trim();
	}
	
	
	/**
	 * formats a string based on "path file" definitions, adding a prefix and a suffix
	 * @param prefix prefix to be added to string
	 * @param token string to be processed
	 * @param suffix suffix to be added to string
	 **/
	public static String formatToken(String prefix, String token, String suffix){
		if (token == null || token.isEmpty())
			return token;
		if (token.charAt(0)=='\"')
			return prefix + removeDoubleQuotes(token) + suffix;
		else
			return prefix + "%" + token + "%" + suffix;
	}

	
	/**
	 * reads a new line from the input buffer
	 * @param br input buffer
	 **/
	public static String readLine(BufferedReader br){
		String tmp = null;
		try {
			tmp = br.readLine();
			if (tmp != null)
				tmp = tmp.trim();
		} catch (Exception e) {
			e.printStackTrace();
		}		
		return tmp;
	}
	
}



/*
=======================================================================================================
											PARAM CLASSES
=======================================================================================================
*/

///**
//* a single parameter in the conversion path
//*/
//public class SingleParam{
//	
//	private String nameForDisplay=null;
//	private String nameInSoftware=null;
//	
//	private boolean discreteParam=false; 
//	private String discreteParamSelected=null;
//	
//	
//	private boolean continuousParam=false; //user has to choose or insert a value
//	private boolean range=false;
//	private String minRange;
//	private String maxRange;
//	private String value=null;	
//	
//	
//	private List<String> possibleValues=null; //null means any value is accepted
//	private List<List<SingleParam>> nestedParams; // possible side-effect steps
//	
//	
//	
//	public String toString() {
//		return this.toString(0);
//	}	
//
//	
//	/**
//	 * display parameters selected (for debug purposes)
//	 * @param level gives the nesting level of the parameters in order to print it nicely
//	 */
//	public String toString(int level) {
//		int j=0;
//		SingleParam ps;
//		List<SingleParam> l_ps;
//		String res="", line="";
//		line+= "display name: " + nameForDisplay;
//		if (discreteParam)
//			line+= " discrete param selected: "+discreteParamSelected;
//		if (continuousParam)
//			line+= " continuous["+minRange+","+maxRange+"]: "+value;
//		res+=print(line, level);
//		line="";
//		if (possibleValues!=null && possibleValues.size()!=0){
//			for(;j<possibleValues.size() && possibleValues.get(j)!=null;j++){
//				line +="possible value: "+ possibleValues.get(j);
//				res+=print(line, level+1);
//				line="";
//				if (nestedParams!=null && j<nestedParams.size()){
//					l_ps = nestedParams.get(j);
//					if (l_ps != null){
//						for(Iterator<SingleParam> itr=l_ps.iterator(); itr.hasNext();){
//							ps=itr.next();
//							res+=ps.toString(level+2);
//						}
//					}
//				}			
//			}
//		}
//		else{
//			res +=print("possible values: ANY", level+1);
//			if (nestedParams!=null && j<nestedParams.size()){
//				l_ps = nestedParams.get(j);
//				if (l_ps != null){
//					for(Iterator<SingleParam> itr=l_ps.iterator(); itr.hasNext();){
//						ps=itr.next();
//						res+=ps.toString(level+2);
//					}
//				}
//			}	
//		}
//		return res;
//  }
//
//	public static String print(String line, int level){
//		String tabs="";
//		while(level>0){
//			tabs+="\t";
//			level--;
//		}
//		return tabs+line+"\n";
//	}
//}
//
//
///**
//* holds parameter data for a specific output format
//*/
//class FormatParams{
//	private String format;
//	private List<SingleParam> paramSelections;
//	
//	/**
//	 * @return the output format
//	 */
//	public String getFormat(){
//		return format;
//	}
//	/**
//	 * @return all parameters possible to be specified for the conversion 
//	 */
//	public List<SingleParam> getParamSelections(){
//		return paramSelections;
//	}
//	
//	public String toString(){
//		SingleParam ps;
//		String str="";
//		str+="format: "+format+"\n";
//		str+="parameters: \n";
//		for(Iterator<SingleParam> itr=paramSelections.iterator(); itr.hasNext();){
//			ps=itr.next();
//			str+=ps.toString(1);
//		}
//		return str;
//	}	
//}
//
//
///**
//* holds all parameter data needed for a single conversion SW
//*/
//class SWParams{
//	private List<FormatParams> formatParams;
//	
//	/**
//	 * @param format the desired output format
//	 * @return parameter data needed for conversion to output format
//	 */
//	public FormatParams getFormatParams(String format){
//		FormatParams fp;
//		for(Iterator<FormatParams> itr=formatParams.iterator(); itr.hasNext();){
//			fp=itr.next();
//			if (fp.getFormat().equals(format))
//				return fp;
//		}
//		System.out.println("Error - format not found");
//		return null;
//	}
//}
//


